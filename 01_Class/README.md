#**类与对象**


##**定义类**
*-定义:*
    1.成员变量（数据）：描述事物的属性;
    2.成员函数（行为）：描述事物能做什么;
*-访问权限控制:*
    1.public:类内外可以直接访问;
    2.private:只有类内部可以访问;
    3.protected:类外部不可访问，子类函数可以访问（继承）;


##**class与struct的区别:**
    唯一区别是默认的访问权限不同：
        1.struct默认是公有public;
        2.class默认是私有private;


##**定义和访问对象**
###*定义:*
    用类定义，类似结构体    比如student s1;
###*访问:*
    用点操作符(.)访问  比如s1.id  注意:不能直接访问private成员，否则会编译错误;


##**this指针**
###*定义:*
    this->变量;
###*作用:*
    用来成员函数中区分形参和成员变量;


##**构造函数和析构函数:**
###*构造函数：*
    1.主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用;对象“出生”时的初始化函数，确保对象在使用前被正确赋值，防止出现随机垃圾值;
    2.*语法*：类名(){};
        a.没有返回值，不写void;
        b.函数名与类名相同;
        c.可以有参数，会有函数重载;
    3.系统自动调用，创建对象时只调用一次;
    4.触发时机是运行时;
    5.分类：
        a.*默认构造函数*，不带任何参数，如 Circle() {}，这是在没写任何构造函数时系统自动的函数，若写了
        构造函数，则没有默认构造函数;
        b.*普通构造函数*，自己写的;
        c.*复制构造函数*：
            (1)*语法*：Circle(const Circle &c)
                    {
                        radius = c.radius; 
                    }
                *必须要用const:* 防止被复制对象被修改;
                *必须要用引用&：*如果不加 &，就会变成 Circle(Circle c)。传参的时候需要复制，复制又会调用复制构造函数，调用又传参……这就陷入了死循环（递归），直到栈溢出
    6.*构造函数重载*：允许一个类有多个构造函数，根据参数列表不同来区分;
    7.*深拷贝 vs 浅拷贝*：
        1.*浅拷贝 (Shallow Copy)*：默认复制构造函数的行为。只复制成员变量的值。对于简单类型（int, double）够用；但对于指针，会导致两个对象指向同一块内存（危险）;
        2.*深拷贝 (Deep Copy)*：手动编写复制构造函数，重新分配内存，确保对象独立;
##*析构函数：*
    1.主要作用在于对象销毁前系统自动调用，执行一些清理工作（如释放内存、关闭文件）;
    2.*语法*: ~类名(){}
        *不允许有参数*;
    3.系统自动调用，创建对象时只调用一次;
    4.*调用顺序（栈的特性）*
        规则：后进先出 (LIFO);
    5.不能重载（一个类只能有一个析构函数）;