[MindMap](./04_Const_and_Mutable.png)

[demo](./demo.cpp)


# C++ 核心机制：Const 与 Mutable 详解

> **核心摘要**：
> `const` 是 C++ 中最重要的设计契约 (Design Contract)，它向编译器和阅读代码的人承诺“这个变量不会被修改”。
> `mutable` 则是为了解决“逻辑常量性”与“物理常量性”矛盾的特殊机制，允许在 `const` 环境下修改特定变量。

## 1. Const 的核心定义与哲学
* **承诺 (Promise)**：一旦声明为 `const`，就意味着该变量在生命周期内不可变。
* **编译期约束**：这是一种编译时的检查机制，试图修改 `const` 变量会导致编译错误 (`Read-only variable is not assignable`)。
* **优化基础**：编译器看到 `const` 后，可能会将变量放入只读内存段 (.rodata)，或进行指令层面的优化。

## 2. 指针中的 Const (难点突破)
记忆口诀：**“以星号 (*) 为界，倒着读” (Read from right to left)**。

| 写法 | 术语 | 含义解读 | 权限 |
| :--- | :--- | :--- | :--- |
| `const int* p` | **底层 Const** (Low-level) | p 指向一个 **int 常量** | 指针可变，内容不可变 |
| `int* const p` | **顶层 Const** (Top-level) | p 是一个 **常量指针** 指向 int | 指针不可变，内容可变 |
| `const int* const p` | **双重 Const** | p 是一个 **常量指针** 指向 **int 常量** | 指针与内容均不可变 |

## 3. 类与成员函数中的 Const
在面向对象编程中，`const` 用于保证对象的状态安全。

### A. Const 成员函数
* **语法**：`void func() const;`
* **本质**：将隐藏的 `this` 指针从 `Type*` 变成了 `const Type*`。
* **限制**：
    1.  该函数内部**不能修改**任何非 `mutable` 成员变量。
    2.  该函数内部**只能调用**其他的 `const` 成员函数（防止间接修改）。
* **最佳实践**：如果一个成员函数不修改对象状态（如 `getScore()`, `isEmpty()`），**必须**加上 `const`。这允许 `const` 对象调用这些方法。

### B. Const 引用传递
* **语法**：`void func(const MyClass& obj);`
* **作用**：
    1.  **效率**：避免对象拷贝（引用传递）。
    2.  **安全**：保证函数内部只读，不产生副作用。

## 4. Mutable 关键字：规则的破坏者
`mutable` 允许成员变量在 `const` 函数中被修改。

### A. 为什么需要它？(逻辑常量性 Logical Constness)
有时候，对象在**逻辑上**没有变化（对外表现一致），但在**物理上**（内存数据）确实变了。常见场景：
* **缓存 (Caching)**：计算结果没变，只是把结果存下来下次直接用。
* **互斥锁 (Mutex)**：为了线程安全上锁，但这不改变对象的业务数据。
* **调试计数**：记录函数被调用的次数。

### B. Lambda 中的 Mutable
* **默认行为**：Lambda 按值捕获 (`[=]`) 的变量默认是只读的。
* **加上 mutable**：`[=]() mutable { ... }` 允许修改捕获进来的**副本**。

## 5. 开发建议
1.  **默认使用 Const**：声明变量时，除非你确定需要修改它，否则一律加上 `const`。
2.  **指针要看清**：区分清楚是“指针不能改”还是“指向的内容不能改”。
3.  **Mutable 慎用**：只用于缓存、同步锁等非业务状态逻辑，不要滥用它来绕过封装。